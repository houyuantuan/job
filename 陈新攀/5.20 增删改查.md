## 1.新增

### a . create()

> val = 类名.objects.create(
>     类属性 = "值"
> 默认和主键可不写
> )

```python
book = BookInfo.objects.create(
btitle = "哆啦A梦",
bpub_date = "1994-8-9",
bcomment = 500000,
bread = 1000000,
)
```

--------

### b.save()

>  val = 类名(
>  类属性 = "值"
> 默认和主键可不写
> )
> val.save()

```python
book = BookInfo(
    btitle = "新约",
    bcomment = 10000000,
    bread = 25000000,
    bpub_date = "0064-1-1"
)
book.save()
```

-------

## 2.改

### a.save

> 先用get查询获取对象 
> 然后对象.s属性名 = “修改后的值”
> 对象.save

```python
book = BookInfo.objects.get(id =13)
book.btitle = "OT"
book.save()
print(book.btitle)
```

-------

### b.update

```python
# 类名.objects.filter(筛选条件).update(类属性=值)
BookInfo.objects.filter(id=13).update(btitle = "bible")   
```

***可以用.all ()代替filter或者get()选中全部内容 ***

```python
BookInfo.objects.all().update(bcomment = 100)
```

--------

## 3.删除

> val = 类名.objects.get/filter(筛选条件)
> val.delete()

```python
book = BookInfo.objects.get(id = 14)
book.delete()
# 删除所有
BookInfo.objects.all().delete()
```



## 4.查询

__exact可以省略

### a.get()

```python
book = BookInfo.objeccts.get(id=1) 
```

### b.all()

```python
books = BookInfo.objects.all() #返回一个查询集
```

### c.filter

```python
# 条件查询。(可以通过逗号,连接多个条件)  返回QuerySet查询集(可以遍历)
books = BookInfo.objects.filter(title = '天龙八部')

# __contains 包含。模糊查询。 (__icontains 不区分大小写)
books = BookInfo.objects.filter(title__contains = '天')

# __endswith 以..结尾。 __startswith 以..开头。 (__iendswith 不区分大小写)
books = BookInfo.objects.filter(title__endswith = '部')  

# __isnull 是否为空。 True：表示为null。 False表示not null
books = BookInfo.objects.filter(title__isnull = False)  

# __in 列表查询
books = BookInfo.objects.filter(id__in = [1,3,5])

# __range 范围查询
books = BookInfo.objects.filter(id__in = [1,5])

# __gt 大于 __lt 小于。 __gte 大于等于。 __lte 小于等于。
books = BookInfo.objects.filter(id__gt = 3)  

# 日期查询。
books = BookInfo.objects.filter(pub_date__gt = date(1980,1,1))  

# 日期查询。(year、month、day、week_day、hour、minute、second)
books = BookInfo.objects.filter(pub_date__year = 1980)   
```

### d.exclude

```python
# 查询id不为3的所有图书。
# 与filter函数作用相反
book = BookInfo.objects.exclude(id=3)
```

### e.order_by

> 正序 从小到大
>
> 倒序 条件前加了”-“ 从大到小

```python
books = BookInfo.objects.order_by("-bread")
```

### f.聚合查询 



> val = 类名.objects.aggregate(Sum("字段名"))
>
> ```python
> from django.db.models import F,Q,Sum,Avg,Count,Max,Min
> sum = BookInfo.objects.aggregate(Sum("bread"))
> avg = BookInfo.objects.aggregate(Avg("bread"))
> count = BookInfo.objects.aggregate(Count("bcomment"))
> ```



### g. F Q

> **F 可以和表内其他属性值比较** >
> ***注意F括号内的字段名要加引号""***
>
> ```python
> book = BookInfo,objects.filter(bread__lt = F("bcomment"))
> ```

------

> **Q 可以进行逻辑与、或、非** 
> ***Q(属性名__运算符=值)***
>
> ```python
> book = BookInfo.objects.filter(Q(bread__gt=20)|Q(id__lte = 3))
> book = BookInfo.objects.filter(Q(bread__gt=20)& Q(id__lte = 3))
> ```

### h.关联查询

>  1.一查多：查询编号为1的图书中所有人物信息

```python
# 先查询出一方模型数据、对象
book = BookInfo.objects.get(id=1)
# 再使用一方模型对象调用 关联的多方模型类小写_set (固定语法)
heros = book.heroinfo_set.all()
for hero in heros:
    print(hero)
```
> 2.多查一：查询编号为1的英雄出自的书籍

```python
# 先查询出多方模型对象
hero = HeroInfo.objects.get(id=1)
# 再使用多方模型对象调用多方模型类中的*#外键#*#属性名
book = hero.hbook
print(book)
```



## filter和get

> **filter得到的是一个QuerySet 查询集 可以返回多个 或者一个空集 可以遍历**>
> **而get得到的是一个定义的model对象 只有返回刚好一个记录时才会正常 否则报错**
>
> **filter有缓存数据的功能，第一次查询数据库并生成缓存，下次再调用filter方法的话，直接取得缓存的数据，get方法每次执行都是直接查询数据库的。**

